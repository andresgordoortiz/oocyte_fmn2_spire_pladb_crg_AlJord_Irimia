---
title: "Alternative Splicing Analysis"
subtitle: "Erwing sarcoma"
author: "Andr√©s Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    code_download: false
    df_print: paged
    number_sections: true

editor_options:
  markdown:
    wrap: 72

header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        /* Base styling */
        body {
          font-family: "Roboto", sans-serif;
          color: #333;
          background-color: #ffffff;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 960px;
          margin: auto;
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 {
          color: #2C3E50;
          text-align: center;
          font-weight: 700;
          margin: 0.5em 0;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.75em; }
        
        /* Text styling */
        p {
          line-height: 1.6;
          margin-bottom: 1em;
          text-align: justify;
        }
        .subtitle, .author, .date {
          text-align: center;
          color: #2C3E50;
          margin-bottom: 0.5em;
        }
        
        /* Links */
        a {
          color: #0275d8;
          text-decoration: none;
        }
        a:hover {
          text-decoration: underline;
        }
        
        /* Tables */
        table {
          width: 100%;
          border-collapse: collapse;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 10px;
        }
        th {
          background-color: #2C3E50;
          color: #fff;
        }
        tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        tr:hover {
          background-color: #f1f1f1;
        }
     </style>'
---




```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")
library("UpSetR")

# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"

```

# Introduction to this Analysis

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Data Acquisition**:
  - Downloading `*.fastq.gz` files of these studies:
    - **FMN2 DKO Oocytes**
    - **SPIRE1/2 DKO Oocytes**
  - Merging technical replicates for superior sequencing depth. RNA Splicing analysis usually requires a minimum of 50 million reads per biological sample.

2. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

3. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. Vast-Tools does **not** find new splicing events, relaying on a manually curated database, [VASTDB](https://vastdb.crg.eu/), with more than 600.000 splicing events. The end result is an `Inclusion_table.tab`, which contains the splicing events as rows and the samples as columns. Splicing is quantified using the Percentage Spliced-In (PSI) parameter, which shows the percentage at which a given splicing event occurs across all sequencing reads of the gene. The database covers the following splicing events:
   
     - **Exons (EX)**: Cassette sequences that are either included or excluded in the mature mRNA.
     - **Introns (IN)**: Introns that are either retained or spliced out in the mature mRNA.
     - **Alternative 5' Splice Sites (Alt5)**: Exons that are spliced at different 5' sites (donor sites).
     - **Alternative 3' Splice Sites (Alt3)**: Exons that are spliced at different 3' sites (acceptor sites).
     - **Microexons (MIC)**: Exons that are shorter than 27 nucleotides.

---

## Part 2: Statistical Analysis

State-of-Art splicing analysis tools such as the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) employ a combination of statistical testing and simulations on the *beta* distribution to calculate the delta PSI (the difference in splicing between two conditions) and the False Discovery rate (FDR, or adjusted p-value) respectively. This is computationally demanding for such a large dataset. For that reason we focused first on analyzing *alternative* splicing events (that is, events with a PSI different that *0* or *100*--not always active, not always inactive) which constitute ~25% of all events in both *FMN2* and *Spire* studies. With that first analysis done (which can be accessed completely in the file `alternative_splicing_fmn2_spire.html`) we fine-tuned the code and used the complete dataset (using both constitutive and alternative events). Additionally, events with less than 10 supporting reads were filtered out (this is the minimum in the field, allowing for maximum sensibility). The specific steps taken for these analysis were.


1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform Beta Distribution simulations to obtain:
     - **False Discovery Rate (FDR)**
     - **delta Percentage Spliced-in (dPSI)**

2. **Filtering Criteria**: Significant events are defined by
     - FDR <= 0.05
     - |dPSI| >= 0.1 (out of 1. That is, at least a 10% increase or decrease in PSI)

All the code history can be accessed through its [GitHub Repository](https://github.com/andresgordoortiz/24crg_adel_manu_oocyte_splicing)

---


```{r inclusion tables}

splicing_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/erwing_PRJNA549593_INCLUSION_LEVELS_FULL-hg19.tab"), tool = "vast-tools")

splicing_events <- filterEvents(getEvents(splicing_data, tool = "vast-tools"), N = 10) 



exons <- filterEvents(splicing_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
introns <- filterEvents(splicing_events, types = c("IR"), N = 10)
alt <- filterEvents(splicing_events, types = c("Alt5", "Alt3"), N = 10)



```


## Metadata { .tabset}

### PladB

```{r metadata pladb}
# Load metadata file containing sample information
metadata<-data.frame(samples=colnames(splicing_events$PSI)[7:10],condition=rep(c("control","siEWS-FLI1"), each=2))
DT::datatable(metadata, options = list(pageLength = nrow(metadata), scrollX = TRUE))
```

---

# Total Splicing Events

This plot shows the total number of splicing events found during the **mapping**, alongside the proportions of each type of event. It is important to know that *vast-tools* does not find new events, but it identifies those manually curated in the database. The total number is the same for both datasets, as it is the total number of events registered and curated in ***VASTDB***, hence the *Complete Version.* 



```{r general stats}
vastdb_events<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
bin_exons <- function(n) {
  if (is.na(n)) return(NA) # Handle missing values
  else if (n < 6) return("1-5")
  else if (n < 9) return("6-10")
  else if (n < 21) return("11-20")
  else return("21+")
}

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_exons<-vastdb_events[grep("EX", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$exon_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_exons<-apply_bin_exons(vastdb_exons)

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_introns<-vastdb_events[grep("IN", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$intron_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_introns<-apply_bin_exons(vastdb_introns)
exons_per_gene<-read.table("coding_unique_exon_counts_per_genehuman.txt")
colnames(exons_per_gene)<-c("gene","exons")

exons_per_gene$gene <- gsub("\\.\\d+$", "", exons_per_gene$gene)

```

# Inclusion or Exclusion Plots { .tabset}

These plots show the distribution of the splicing change (dPSI) comparing the KO mutant vs the control. If there is a tendency towards inclusion or exclusion, the bell-shaped curve will be shifted to the right or left, respectively. First, I calculated the mean of each event per condition and then I calculated the difference between means for each event. The subtitle shows the Wilcoxon test assessing this possible asymmetry. The area under the curve for both sides (>0 and <0) is shown numerically. Only events with a dPSI greater or lower than 0 are shown for clarity.

## Exons 

### Tubercidin

```{r inclusionumber of exons tub, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
exons_df <- exons$PSI %>% 
  filter(complete.cases(select(., 7:10)))

# Compute the averages and PSI difference for each row
exons_df <- exons_df %>% 
  mutate(
    avg_control = rowMeans(select(., 7:8)),
    avg_siEWS_FLI1 = rowMeans(select(., 9:10)),
    difference = avg_siEWS_FLI1 - avg_control
  ) %>% 
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(exons_df) > 5000) {
  shapiro_sample <- sample(exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(exons_df$difference > 0) * 100, 1)
n_samples <- nrow(exons_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  exons_df[abs(exons_df$difference) > 0, ], 
  aes(x = difference)
) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0), 
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ŒîPSI (siEWS-FLI1 - Control)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Assign colors explicitly to match annotations
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),
    labels = c("ŒîPSI < 0", "ŒîPSI > 0")
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("ŒîPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 5, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("ŒîPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 5, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/erwing_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)


```

```{r skewness tub}

ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("hgnc_symbol", "ensembl_gene_id"),
  filters = "hgnc_symbol",
  values = exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
exons_df <- exons_df %>%
  left_join(gene_conversion %>% select(hgnc_symbol, ensembl_gene_id), by = c("GENE" = "hgnc_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- exons_df %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1‚Äì10", "11‚Äì50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime") 
library(showtext)
showtext_auto()

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1‚Äì10", "11‚Äì50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +
  
  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30", 
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1‚Äì10"  = "#d1cbe5",
    "11‚Äì50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21, 
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +
            

  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ŒîPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5)

print(p)


ggsave("erwing_exons.svg",
       width  = 6,
       height = 6)

```



# PCA Plot { .tabset}


```{r pca calculation pladb}
# Subset and scale data
pca_splicing <- splicing_events$PSI[, c("EVENT",splicing_events$Samples)] %>%
  na.omit()

rownames(pca_splicing)<- pca_splicing$EVENT
pca_splicing<-t(pca_splicing[,-1])


pca_result <- prcomp(pca_splicing)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata$condition
```

```{r pca plotting pladb}
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition))) +
  geom_point(size = 6, alpha = 0.9) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14, margin = margin(t = 10)),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_color_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()
ggsave("final_plots/pca_pladb.svg", pca_plot, width = 5, height = 5, dpi = 300)


pca_plot

```

# Exon Lists

```{r aux_featuregroup}
# Extract unique groups and sample IDs



groups<- unique(metadata[, "condition"])
samples <- metadata$samples


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")


# Create group list with metadata
groupList <- lapply(1:length(groups), function(i) {
  list(
    name = groups[i],
    samples = samples[metadata[, "condition"] == groups[i]],
    color = random_colors[i]
  )
})
names(groupList) <- groups



group_control<-"control"
group_si<-"siEWS-FLI1"



#samples_controlpladb <- groupList[[group_controlpladb]]$samples
samples_control <- groupList[[group_control]]$samples
#samples_pladb <- groupList[[group_pladB]]$samples
samples_si <- groupList[[group_si]]$samples


#colsGroup_controlpladb <- convertCols(splicing_events$PSI, samples_controlpladb)
colsGroup_control <- convertCols(splicing_events$PSI, samples_control)
#colsGroup_pladb <- convertCols(splicing_events$PSI, samples_pladb)
colsGroup_si<- convertCols(splicing_events$PSI, samples_si)


```

## Calculations

```{r pdiff calculations}
set.seed(42) #Setting seed for downstream simulations of the beta distribution

# Prepare table for fmn2dko
erwing_fdr <- prepareTableVolcanoFDR(
  psitable = splicing_events$PSI,
  qualtable = splicing_events$Qual,
  npoints = 500,
  colsA = colsGroup_control,
  colsB = colsGroup_si,
  labA = colsGroup_control,
  labB = colsGroup_si,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)


write.csv(erwing_fdr,"erwing_fdr.csv")


tub_fdr_df<-read.csv("tables_10n/tub_fdr.csv")[,-1]
pladb_fdr_df<-read.csv("tables_10n/pladb_fdr.csv")[,-1]
ssa_fdr_df<-read.csv("tables_10n/ssa_fdr.csv")[,-1]

consertable<- read.delim("EVENT_CONSERVATION.tab", header = TRUE, sep = "\t") %>%
  filter(grepl("Mmu", EventID))


tub_human <- tub_fdr_df %>%
  filter(FDR <= 0.05) %>%
  left_join(consertable %>% select(EventID, ConservedID),
            by = c("EVENT" = "EventID")) %>%
  filter(grepl("Hsa", ConservedID)) %>%
  # here: replace tiny deltapsi with 0
  mutate(deltapsi = if_else(abs(deltapsi) < 0.001, 0, deltapsi)) %>%
  select(GENE, EVENT, deltapsi, ConservedID) %>%
  distinct(EVENT, .keep_all = TRUE)


      
pladb_human <- pladb_fdr_df %>%
  filter(FDR<=0.05) %>%
    left_join(consertable %>% select(EventID, ConservedID), by = c("EVENT" = "EventID")) %>%
      filter(grepl("Hsa",ConservedID)) %>%
    mutate(deltapsi = if_else(abs(deltapsi) < 0.001, 0, deltapsi)) %>%
      select(GENE, EVENT, deltapsi, ConservedID) %>%
  distinct(EVENT, .keep_all = TRUE)


ssa_human <- ssa_fdr_df %>%
  filter(FDR<=0.05) %>%
    left_join(consertable %>% select(EventID, ConservedID), by = c("EVENT" = "EventID")) %>%
      filter(grepl("Hsa",ConservedID)) %>%
    mutate(deltapsi = if_else(abs(deltapsi) < 0.001, 0, deltapsi)) %>%
      select(GENE, EVENT, deltapsi, ConservedID) %>%
  distinct(EVENT, .keep_all = TRUE)

      
      

differential_tub<-na.omit(tub_fdr_df[tub_fdr_df$FDR <= 0.05 & abs(tub_fdr_df$deltapsi) >= 0.1,])

differential_pladb<-na.omit(pladb_fdr_df[pladb_fdr_df$FDR <= 0.05 & abs(pladb_fdr_df$deltapsi) >= 0.1,])

differential_ssa<-na.omit(ssa_fdr_df[ssa_fdr_df$FDR <= 0.05 & abs(ssa_fdr_df$deltapsi) >= 0.1,])

```




## Volcano Plots { .tabset}


### Tuberdicine

```{r tub fdr volcano exons}
tub_exons<-tub_fdr_df[grepl("EX",tub_fdr_df$EVENT),]

differential_tub_exons<-differential_tub[grepl("EX",differential_tub$EVENT),]
differential_pladb_exons<-differential_pladb[grepl("EX",differential_pladb$EVENT),]
differential_ssa_exons<-differential_ssa[grepl("EX",differential_ssa$EVENT),]


shared_exons<-intersect(differential_tub_exons$EVENT, differential_pladb_exons$EVENT)
shared_exons<-intersect(shared_exons, differential_ssa_exons$EVENT)

library(ggrepel)
# Add a Shared column based on the shared_exons
tub_exons$Shared <- ifelse(tub_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
tub_exons$Significant <- ifelse(
  tub_exons$FDR <=0.05 & tub_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tub_exons$FDR <=0.05 & tub_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tub_exons$negLogpvalue <- -log10(tub_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tub_exons <- tub_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tub_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tub_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tub_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "sans") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_tub_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_tub_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)


volcano_plot
```

### PladB

```{r plab fdr volcano exons}
pladb_exons<-pladb_fdr_df[grepl("EX",pladb_fdr_df$EVENT),]


# Add a Shared column based on the shared_exons
pladb_exons$Shared <- ifelse(pladb_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
pladb_exons$Significant <- ifelse(
  pladb_exons$FDR <=0.05 & pladb_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_exons$FDR <=0.05 & pladb_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_exons$negLogpvalue <- -log10(pladb_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_exons <- pladb_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_pladb_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_pladb_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot


```


### Spliceostatin A

```{r ssa fdr volcano exons}
ssa_exons<-ssa_fdr_df[grepl("EX",ssa_fdr_df$EVENT),]


# Add a Shared column based on the shared_exons
ssa_exons$Shared <- ifelse(ssa_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
ssa_exons$Significant <- ifelse(
  ssa_exons$FDR <=0.05 & ssa_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    ssa_exons$FDR <=0.05 & ssa_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
ssa_exons$negLogpvalue <- -log10(ssa_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
ssa_exons <- ssa_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(ssa_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(ssa_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(ssa_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Spliceostatin A - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of SSA Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("final_plots/volcano_ssa_exons.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("final_plots/volcano_ssa_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot


```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 


### Tubercidin

```{r tub combination table exons}
# Render DataTable with enhancements
datatable(
  differential_tub_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### PladB

```{r pladb combination table exons}
# Render DataTable with enhancements
datatable(
  differential_pladb_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spliceostatin A

```{r ssa combination table exons}
# Render DataTable with enhancements
datatable(
  differential_ssa_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

# Intron Lists

## Calculations

```{r pdiff calculation introns}

differential_tub_introns<-differential_tub[grepl("INT",differential_tub$EVENT),]
differential_pladb_introns<-differential_pladb[grepl("INT",differential_pladb$EVENT),]
differential_ssa_introns<-differential_ssa[grepl("INT",differential_ssa$EVENT),]


shared_introns<-intersect(differential_tub_introns$EVENT,differential_pladb_introns$EVENT)
shared_introns<-intersect(shared_introns,differential_ssa_introns$EVENT)


```



## Volcano Plots { .tabset}


### Tubercidin

```{r tub volcano introns}

tub_introns<-tub_fdr_df[grepl("INT",tub_fdr_df$EVENT),]

# Add a Shared column based on the shared_exons
tub_introns$Shared <- ifelse(tub_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
tub_introns$Significant <- ifelse(
  tub_introns$FDR <=0.05 & tub_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tub_introns$FDR <=0.05 & tub_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tub_introns$negLogpvalue <- -log10(tub_introns$FDR)


# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tub_introns <- tub_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tub_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tub_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tub_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_tub_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_tub_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### PladB

```{r pladb volcano introns}
pladb_introns<-pladb_fdr_df[grepl("INT",pladb_fdr_df$EVENT),]

pladb_introns$Shared <- ifelse(pladb_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
pladb_introns$Significant <- ifelse(
  pladb_introns$FDR <=0.05 & pladb_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_introns$FDR <=0.05 & pladb_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_introns$negLogpvalue <- -log10(pladb_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_introns <- pladb_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_pladb_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_pladb_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### Spliceostatin A

```{r ssa volcano introns}
ssa_introns<-ssa_fdr_df[grepl("INT",ssa_fdr_df$EVENT),]

ssa_introns$Shared <- ifelse(ssa_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
ssa_introns$Significant <- ifelse(
  ssa_introns$FDR <=0.05 & ssa_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    ssa_introns$FDR <=0.05 & ssa_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
ssa_introns$negLogpvalue <- -log10(ssa_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
ssa_introns <- ssa_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(ssa_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(ssa_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(ssa_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (SSA - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spliceostatin A Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_ssa_introns.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_ssa_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 

### Tubercidin

```{r tub combination table introns}
# Render DataTable with enhancements
datatable(
  differential_tub_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### PladB


```{r pladb combination table introns}
# Render DataTable with enhancements
datatable(
  differential_pladb_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

### Spliceostatin A


```{r ssa combination table introns}
# Render DataTable with enhancements
datatable(
  differential_ssa_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```


# Alternative 5¬¥ & 3¬¥

## Calculations

```{r pdiff calculation alt}

differential_tub_alt<-differential_tub[grepl("ALT",differential_tub$EVENT),]
differential_pladb_alt<-differential_pladb[grepl("ALT",differential_pladb$EVENT),]
differential_ssa_alt<-differential_ssa[grepl("ALT",differential_ssa$EVENT),]


shared_alt<-intersect(differential_tub_alt$EVENT,differential_pladb_alt$EVENT)
shared_alt<-intersect(shared_alt,differential_ssa_alt$EVENT)


```



## Volcano Plots { .tabset}


### Tubercidin

```{r tub volcano alt}

tub_alt<-tub_fdr_df[grepl("ALT",tub_fdr_df$EVENT),]

# Add a Shared column based on the shared_exons
tub_alt$Shared <- ifelse(tub_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
tub_alt$Significant <- ifelse(
  tub_alt$FDR <=0.05 & tub_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tub_alt$FDR <=0.05 & tub_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tub_alt$negLogpvalue <- -log10(tub_alt$FDR)


# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tub_alt <- tub_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tub_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tub_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tub_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin Alt",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_tub_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_tub_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### PladB

```{r pladb volcano alt}
pladb_alt<-pladb_fdr_df[grepl("ALT",pladb_fdr_df$EVENT),]

pladb_alt$Shared <- ifelse(pladb_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
pladb_alt$Significant <- ifelse(
  pladb_alt$FDR <=0.05 & pladb_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    pladb_alt$FDR <=0.05 & pladb_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
pladb_alt$negLogpvalue <- -log10(pladb_alt$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
pladb_alt <- pladb_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(pladb_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(pladb_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(pladb_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB Alt",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_pladb_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_pladb_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

### Spliceostatin A

```{r ssa volcano alt}
ssa_alt<-ssa_fdr_df[grepl("ALT",ssa_fdr_df$EVENT),]

ssa_alt$Shared <- ifelse(ssa_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
ssa_alt$Significant <- ifelse(
  ssa_alt$FDR <=0.05 & ssa_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    ssa_alt$FDR <=0.05 & ssa_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
ssa_alt$negLogpvalue <- -log10(ssa_alt$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
ssa_alt <- ssa_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(ssa_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(ssa_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(ssa_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (SSA - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spliceostatin A Alt",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_ssa_alt.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)
ggsave("volcano_ssa_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 

### Tubercidin

```{r tub combination table alt}
# Render DataTable with enhancements
datatable(
  differential_tub_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### PladB


```{r pladb combination table alt}
# Render DataTable with enhancements
datatable(
  differential_pladb_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

### Spliceostatin A


```{r ssa combination table alt}
# Render DataTable with enhancements
datatable(
  differential_ssa_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```

# All Event Types Volcano Plots { .tabset}


## Tubercidin

```{r tub all volcano }

mega_volcano<-rbind(tub_introns,tub_exons,tub_alt)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (Tubercidin - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Tubercidin All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_tub_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_tub_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

## PladB

```{r pladb fdr volcano all}
mega_volcano<-rbind(pladb_alt,pladb_introns,pladb_exons)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (PladB - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of PladB All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_pladb_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_pladb_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

## Spliceostatin A

```{r ssa fdr volcano all}
mega_volcano<-rbind(ssa_alt,ssa_introns,ssa_exons)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "‚â•2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("‚â•", max_y), x)
  ) +
  labs(
    x = "Delta PSI (SSA - Control)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spliceostatin A All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_ssa_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72)
ggsave("volcano_ssa_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 1200)

volcano_plot
```

# Basic Stats on Found Events

## Events-level stats

```{r basic stats}
# Define study-specific data
tub_exons_df <- data.frame(EVENT = differential_tub_exons$EVENT, Type = "Exons", Study = "Tubercidin")
tub_introns_df <- data.frame(EVENT = differential_tub_introns$EVENT, Type = "Introns", Study = "Tubercidin")
tub_alt_df <- data.frame(EVENT = differential_tub_alt$EVENT, Type = "Alt", Study = "Tubercidin")

pladb_exons_df <- data.frame(EVENT = differential_pladb_exons$EVENT, Type = "Exons", Study = "pladb")
pladb_introns_df <- data.frame(EVENT = differential_pladb_introns$EVENT, Type = "Introns", Study = "pladb")
pladb_alt_df <- data.frame(EVENT = differential_pladb_alt$EVENT, Type = "Alt", Study = "pladb")

ssa_exons_df <- data.frame(EVENT = differential_ssa_exons$EVENT, Type = "Exons", Study = "Spliceostatin")
ssa_introns_df <- data.frame(EVENT = differential_ssa_introns$EVENT, Type = "Introns", Study = "Spliceostatin")
ssa_alt_df <- data.frame(EVENT = differential_ssa_alt$EVENT, Type = "Alt", Study = "Spliceostatin")

# Define subsets for each event type
event_list_exons <- list(
  Tubercidin_Exons  = unique(tub_exons_df$EVENT),
  Pladb_Exons = unique(pladb_exons_df$EVENT),
  Spliceostatin_Exons = unique(ssa_exons_df$EVENT)
)

event_list_introns <- list(
  Tubercidin_Introns  = unique(tub_introns_df$EVENT),
  Pladb_Introns = unique(pladb_introns_df$EVENT),
  Spliceostatin_Introns = unique(ssa_introns_df$EVENT)
)

event_list_alt <- list(
  Tubercidin_Alt  = unique(tub_alt_df$EVENT),
  Pladb_Alt = unique(pladb_alt_df$EVENT),
  Spliceostatin_Alt = unique(ssa_alt_df$EVENT)
)

# Define colors
color_exons <- c("#4E79A7", "#4E79A7","#4E79A7")  # Blue for exons
color_introns <- c("#F28E2B", "#F28E2B","#F28E2B")  # Orange for introns
color_alt <- c("#E15759", "#E15759","#E15759")  # Red for alternative splicing events

# Generate UpSet plots
p_exons<-upset(fromList(event_list_exons),
                 nsets = 3,
                 order.by = "freq",
                 sets.bar.color = color_exons,
                 mainbar.y.label = "Exon Overlapping Events",
                 sets.x.label = "Number of Exon Events",
                 text.scale = 2)

p_introns <- upset(fromList(event_list_introns),
                   nsets = 3,
                   order.by = "freq",
                   sets.bar.color = color_introns,
                   mainbar.y.label = "Intron Overlapping Events",
                   sets.x.label = "Number of Intron Events",
                   text.scale = 2)

p_alt <- upset(fromList(event_list_alt),
               nsets = 3,
               order.by = "freq",
               sets.bar.color = color_alt,
               mainbar.y.label = "Alt Overlapping Events",
               sets.x.label = "Number of Alt Events",
               text.scale = 2)


p_exons
p_introns
p_alt
```

## Gene-level stats

```{r, basic gene stats}

gene_list <- list(
  Tubercidin  = unique(c(differential_tub_exons$GENE,differential_tub_introns$GENE,differential_tub_alt$GENE)),
  Pladb = unique(c(differential_pladb_exons$GENE,differential_pladb_introns$GENE,differential_pladb_alt$GENE)),
  Spliceostatin  = unique(c(differential_ssa_exons$GENE,differential_ssa_introns$GENE,differential_ssa_alt$GENE))
)


shared_genes<-intersect(gene_list$Tubercidin,gene_list$Pladb)
shared_genes<-intersect(shared_genes, gene_list$Spliceostatin)
# Generate UpSet plots
p_genes<-upset(fromList(gene_list),
                 nsets = 3,
                 order.by = "freq",
                 sets.bar.color = "#0099cf",
                 mainbar.y.label = "Overlapping Genes",
                 sets.x.label = "Number of Genes",
                 text.scale = 2)

p_genes
```



# Gene-centric Analysis { .tabset}

The following analysis identifies the number of significant events a given gene has. This number of *hits* serves as a proxy of how heavily influenced by splicing a given gene has been. The table shows how many genes classified by the number of significant events I have found, alongside the proportion of ORF disruption for each group. The plot then shows the list of genes, with at least 3 *hits*, in the x-axis, their average |dPSI| in the y-axis, and the shape of the points shows whether that given event is ORF-disrupted.

## Tubercidin

```{r gene-centric plot fmn2 prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, 
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_tub_exons,
  introns = differential_tub_introns,
  alt = differential_tub_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene ‚ÄúORF disrupted‚Äù if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r fmn2 gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in Tubercidin",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("final_plots/tub_splicing_events_plot.svg", plot = p2, width = 24, height = 10)

# Display the plot
print(p2)
```


## PladB

```{r gene-centric plot pladb prep}
# Set seed for reproducibility
set.seed(44)



# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_pladb_exons,
  introns = differential_pladb_introns,
  alt = differential_pladb_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene ‚ÄúORF disrupted‚Äù if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r pladb gene-centric plot, fig.width=30, fig.height=12}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.7) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in PladB",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("pladb_splicing_events_plot.svg", plot = p2, width = 30, height = 12, dpi = 300)

# Display the plot
print(p2)
```

## Spliceostatin A

```{r gene-centric plot ssa prep}
# Set seed for reproducibility
set.seed(44)



# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_ssa_exons,
  introns = differential_ssa_introns,
  alt = differential_ssa_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene ‚ÄúORF disrupted‚Äù if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF-shifted genes" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r ssa gene-centric plot, fig.width=30, fig.height=12}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.7) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in Spliceostatin",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("ssa_splicing_events_plot.svg", plot = p2, width = 30, height = 12, dpi = 300)

# Display the plot
print(p2)
```

# Heatmap Tubercidin


```{r heatmap prep, results='hide', fig.show='hide'}
# Load required libraries
library(ComplexHeatmap)
library(circlize)
library(viridis)    # for viridis palette
library(dplyr)
library(grid)
library(tidyr)      # if needed for replace_na
library(enrichR)    # assuming enrichr() is from enrichR package

set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix

tub_exons_df <- exons_ssa_tub$PSI %>% 
  filter(complete.cases(select(., 7:12)))

tub_unique <- tub_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(tub_unique) <- tub_unique$EVENT

tub_unique_all<-tub_unique
# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_tub_exons$EVENT[abs(differential_tub_exons$deltapsi)>=0.2],
  differential_tub_introns$EVENT[abs(differential_tub_introns$deltapsi)>=0.2]
))
tub_unique <- tub_unique[rownames(tub_unique) %in% filtered_events, ] %>%
  select(7:12) %>%
  as.matrix()
  


# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(tub_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(0, 50, 100),
  viridis(3)
)

number_splices <- 4

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = ssa_tub_events$PSI$EVENT,
  GENE = ssa_tub_events$PSI$GENE
  )


# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  tub_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(tub_unique)
final_impact <- data.frame(EventID = rownames(tub_unique)) %>%  
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5¬¥UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(spire_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}



```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------
#colnames(spire_unique) <- c("Control 1", "Control 2", "Control 3", "Spire KO 1", "Spire KO 2", "Spire KO 3")

ht <- Heatmap(
  tub_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Spire Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.2",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility
  
)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- tub_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_spire<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short tub, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

tub_unique_short <- cbind(
  rowMeans(tub_unique[, 1:3]),
  rowMeans(tub_unique[, 4:6])
)

# Convert to matrix and print result
colnames(tub_unique_short) <- c("Control", "Tubercidin")

spire_unique_short <- tub_unique_short[row_order,]

ht <- Heatmap(
  tub_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)

# Draw the heatmap




```


### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts that the protein impact does not alter the splicing tendency: some events (grey dots in the plot) will be included or excluded, but the population means of the WT and KO remain equal.

```{r protein impact psi spire, out.width="100%"}
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)
library(ggpubr)

# Filter and reshape data
filtered_events <- unique(c(
  differential_tub_exons$EVENT,
  differential_tub_introns$EVENT
))

tub_mat <- tub_unique_all[rownames(tub_unique_all) %in% filtered_events, ] %>%
  select(7:12) %>%
  as.matrix()

original_cols <- colnames(tub_mat)

tub_df <- as.data.frame(tub_mat) %>%
  rownames_to_column("EVENT") %>%
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) %>%
  mutate(
    group_idx = match(sample, original_cols),
    protein_impact = final_impact_string$ONTO[match(EVENT, final_impact_string$EventID)],
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disruption upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disruption upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ "Unknown"
    ),
    group = ceiling(group_idx/3),
    condition = factor(if_else(str_detect(sample, "tub"), "Tubercidin", "Control"),
                       levels = c("Control", "Tubercidin"))
  ) %>%
  select(-group_idx)

# Bootstrap confidence intervals
bootstrap_ci <- function(x, nboot = 1000, conf = 0.95) {
  boots <- replicate(nboot, mean(sample(x, replace = TRUE)))
  quantile(boots, c((1 - conf) / 2, 1 - (1 - conf) / 2), na.rm = TRUE)
}

# Summaries per group with direct CI extraction
summary_df <- tub_df %>%
  group_by(protein_impact, condition) %>%
  summarise(
    mean_val   = mean(value),
    n          = n(),
    ci_lower   = bootstrap_ci(value)[1],
    ci_upper   = bootstrap_ci(value)[2],
    .groups    = "drop"
  )

# Statistical tests per facet
tests <- tub_df %>%
  group_by(protein_impact) %>%
  t_test(value ~ condition) %>%
  adjust_pvalue(method = "BH") %>%
  add_significance() %>%
  add_xy_position(x = "condition")

# Determine y-axis upper limit
y_max <- max(tub_df$value, na.rm = TRUE) * 1.1

# Create the plot
impact_psi_plot <- ggplot(summary_df, aes(x = condition, y = mean_val, color = protein_impact, fill = protein_impact)) +
  # raw points
  geom_jitter(data = tub_df, aes(x = condition, y = value), width = 0.15, size = 1, alpha = 0.5, color = "grey50") +
  # mean lines & points
  geom_line(aes(group = protein_impact), size = 1) +
  geom_point(size = 3) +
  # confidence ribbons
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  # add p-value bars & stars
  stat_pvalue_manual(tests, label = "p.adj.signif", tip.length = 0.02, bracket.size = 0.4) +
  # facets
  facet_wrap(~ protein_impact, scales = "free_y", ncol = 3) +
  # axes and limits
  scale_y_continuous(limits = c(0, y_max), expand = expansion(mult = c(0.02, 0.05))) +
  # color palette
  scale_color_brewer(palette = "Set2") +
  scale_fill_brewer(palette = "Set2") +
  # theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(color = "grey90"),
    strip.text        = element_text(face = "bold", size = 12),
    axis.title        = element_text(face = "bold"),
    legend.position   = "bottom"
  ) +
  labs(
    x               = "Condition",
    y               = "Mean PSI",
    color           = "Protein Impact",
    fill            = "Protein Impact"
  )

# Save
ggsave("final_plots/protein_impact_plot_tub_improved.svg", impact_psi_plot, width = 12, height = 8)

impact_psi_plot


```


# Heatmap Spliceostatin A


```{r heatmap prep ssa, results='hide', fig.show='hide'}


set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix

ssa_exons_df <- exons_ssa_tub$PSI %>% 
  filter(complete.cases(select(., c(7:9, 13:15))))

ssa_unique <- ssa_exons_df %>% distinct(EVENT, .keep_all = TRUE)
rownames(ssa_unique) <- ssa_unique$EVENT

ssa_unique_all<-ssa_unique
# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_ssa_exons$EVENT[abs(differential_ssa_exons$deltapsi)>=0.2],
  differential_ssa_introns$EVENT[abs(differential_ssa_introns$deltapsi)>=0.2]
))
ssa_unique <- ssa_unique[rownames(ssa_unique) %in% filtered_events, ] %>%
  select(c(7:9, 13:15)) %>%
  as.matrix()
  


# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(ssa_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(0, 50, 100),
  viridis(3)
)

number_splices <- 4

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = ssa_tub_events$PSI$EVENT,
  GENE = ssa_tub_events$PSI$GENE
  )


# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  ssa_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(ssa_unique)
final_impact <- data.frame(EventID = rownames(ssa_unique)) %>%  
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5¬¥UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(spire_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}



```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot ssa, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------
#colnames(spire_unique) <- c("Control 1", "Control 2", "Control 3", "Spire KO 1", "Spire KO 2", "Spire KO 3")

ht <- Heatmap(
  ssa_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Spire Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.2",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:6,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility
  
)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final ssa}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- ssa_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_ssa<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short ssa, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

ssa_unique_short <- cbind(
  rowMeans(ssa_unique[, 1:3]),
  rowMeans(ssa_unique[, 4:6])
)

# Convert to matrix and print result
colnames(ssa_unique_short) <- c("Control", "Spliceostatin")

spire_unique_short <- ssa_unique_short[row_order,]

ht <- Heatmap(
  ssa_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)

# Draw the heatmap




```


### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts that the protein impact does not alter the splicing tendency: some events (grey dots in the plot) will be included or excluded, but the population means of the WT and KO remain equal.

```{r protein impact psi ssa, out.width="100%"}
# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)
library(ggpubr)

# Filter and reshape data
filtered_events <- unique(c(
  differential_ssa_exons$EVENT,
  differential_ssa_introns$EVENT
))

ssa_mat <- ssa_unique_all[rownames(ssa_unique_all) %in% filtered_events, ] %>%
  select(c(7:9, 13:15)) %>%
  as.matrix()

original_cols <- colnames(ssa_mat)

ssa_df <- as.data.frame(ssa_mat) %>%
  rownames_to_column("EVENT") %>%
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) %>%
  mutate(
    group_idx = match(sample, original_cols),
    protein_impact = final_impact_string$ONTO[match(EVENT, final_impact_string$EventID)],
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disruption upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disruption upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ "Unknown"
    ),
    group = ceiling(group_idx/3),
    condition = factor(if_else(str_detect(sample, "ssa"), "Spliceostatin", "Control"),
                       levels = c("Control", "Spliceostatin"))
  ) %>%
  select(-group_idx)

# Bootstrap confidence intervals
bootstrap_ci <- function(x, nboot = 1000, conf = 0.95) {
  boots <- replicate(nboot, mean(sample(x, replace = TRUE)))
  quantile(boots, c((1 - conf) / 2, 1 - (1 - conf) / 2), na.rm = TRUE)
}

# Summaries per group with direct CI extraction
summary_df <- ssa_df %>%
  group_by(protein_impact, condition) %>%
  summarise(
    mean_val   = mean(value),
    n          = n(),
    ci_lower   = bootstrap_ci(value)[1],
    ci_upper   = bootstrap_ci(value)[2],
    .groups    = "drop"
  )

# Statistical tests per facet
tests <- ssa_df %>%
  group_by(protein_impact) %>%
  t_test(value ~ condition) %>%
  adjust_pvalue(method = "BH") %>%
  add_significance() %>%
  add_xy_position(x = "condition")

# Determine y-axis upper limit
y_max <- max(ssa_df$value, na.rm = TRUE) * 1.1

# Create the plot
impact_psi_plot <- ggplot(summary_df, aes(x = condition, y = mean_val, color = protein_impact, fill = protein_impact)) +
  # raw points
  geom_jitter(data = ssa_df, aes(x = condition, y = value), width = 0.15, size = 1, alpha = 0.5, color = "grey50") +
  # mean lines & points
  geom_line(aes(group = protein_impact), size = 1) +
  geom_point(size = 3) +
  # confidence ribbons
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  # add p-value bars & stars
  stat_pvalue_manual(tests, label = "p.adj.signif", tip.length = 0.02, bracket.size = 0.4) +
  # facets
  facet_wrap(~ protein_impact, scales = "free_y", ncol = 3) +
  # axes and limits
  scale_y_continuous(limits = c(0, y_max), expand = expansion(mult = c(0.02, 0.05))) +
  # color palette
  scale_color_brewer(palette = "Set2") +
  scale_fill_brewer(palette = "Set2") +
  # theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(color = "grey90"),
    strip.text        = element_text(face = "bold", size = 12),
    axis.title        = element_text(face = "bold"),
    legend.position   = "bottom"
  ) +
  labs(
    x               = "Condition",
    y               = "Mean PSI",
    color           = "Protein Impact",
    fill            = "Protein Impact"
  )

# Save
ggsave("final_plots/protein_impact_plot_ssa_improved.svg", impact_psi_plot, width = 12, height = 8)

impact_psi_plot


```


# Splicing Dynamics Heatmap FMN2


```{r heatmap pre-prep fmn2, results='hide', fig.show='hide'}

# Extract all events
fmndko_all<- filterEvents(
  fmndko_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR","Alt3","Alt5"),
  N = 10
)
```

```{r heatmap prep fmn2, results='hide', fig.show='hide'}


set.seed(44)

# --------------------------
# Data Preparation
# --------------------------
# Get unique splicing events (remove NA events) and convert selected PSI columns to matrix
fmndko_unique <- fmndko_all$PSI %>% distinct(EVENT, .keep_all = TRUE)
fmndko_unique <- fmndko_unique[!is.na(fmndko_unique$EVENT), ]
rownames(fmndko_unique) <- fmndko_unique$EVENT
fmndko_unique <- as.matrix(fmndko_unique[,7:10])

# Filter rows based on differential events (|dPSI| >= 0.1)
filtered_events <- unique(c(
  differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
  differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"]
))
fmndko_unique <- fmndko_unique[rownames(fmndko_unique) %in% filtered_events, ]

# Create a dendrogram for the columns (using hierarchical clustering on the transposed data)
col_dend <- hclust(dist(t(fmndko_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2)

# Define a color function using a viridis palette.
# Here we assume the PSI values range from 0 to 100 with a midpoint at 50.
col_fun <- colorRamp2(
  c(0, 50, 100),
  viridis(3)
)

number_splices <- 6

# Create a reference table for enrichment analysis by combining events and genes
reference_table <- data.frame(
  EVENT = c(
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "EVENT"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "EVENT"]
  ),
  GENE = c(
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi) >= 0.1, "GENE"],
    differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi) >= 0.1, "GENE"]
  )
)

# --------------------------
# Initial Heatmap and Annotations
# --------------------------
# Calculate the initial heatmap to obtain cluster order
ht <- Heatmap(
  fmndko_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = 1:4,
  row_km = number_splices,
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(8, "mm"),      # increased gap for white space between rows
  column_gap = unit(8, "mm"),   # increased gap for white space between columns
  rect_gp = gpar(col = "white", lwd = 0.3),
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),
    legend_direction = "vertical"
  )
)
ht <- draw(ht)
clustered_events <- row_order(ht)

# Build the left annotation: Protein impact points.
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")
events_for_impact <- rownames(fmndko_unique)
final_impact <- data.frame(EventID = rownames(fmndko_unique)) %>%  
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),
    size = unit(4, "mm"),
    axis_param = list(
      side = "top",
      at = -2:2,
      labels = c(
        "Regulatory (5¬¥UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45,
      gp = gpar(fontsize = 15)
    )
  )
)

# Perform enrichment analysis for each cluster and prepare right annotation text.
text_list <- list()
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(fmndko_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)



```


### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot fmn2, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

# --------------------------
# Final Heatmap with Annotations
# --------------------------
colnames(fmndko_unique) <- c("Control 1", "Control 2", "FMN2 KO 1", "FMN2 KO 2")

ht <- Heatmap(
  fmndko_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes FMN2 Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 0,
  column_dend_reorder = 1:4,
  row_km = number_splices,
  left_annotation = left_annotation,    # Protein impact annotation on left
  right_annotation = right_annotation,  # Enrichment annotation on right
  row_dend_reorder = FALSE,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "black"),
  show_row_names = FALSE,
  row_gap = unit(5, "mm"),      # Increased white space between rows
  column_gap = unit(5,"mm"),   # Increased white space between columns
  rect_gp = gpar(col = "white", lwd = 0.1),  # Adjusted white grid visibility
  
)
ht <- draw(ht)

# Decorate the right annotation slices with the enrichment text.
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}
```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap fmn2 final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- fmndko_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_spire<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

fmndko_unique_short <- cbind(
  rowMeans(fmndko_unique[, 1:2]),
  rowMeans(fmndko_unique[, 3:4])
)

# Convert to matrix and print result
colnames(fmndko_unique_short) <- c("Control", "FMN2KO")

fmndko_unique_short <- fmndko_unique_short[row_order,]

ht <- Heatmap(
  fmndko_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)



```

### Protein Impact on Splicing Events

I extracted the different subsets of significant splicing events and grouped them by the protein impact. The plot depicts events ORF-disrupted upon inclusion being generally excluded (the proteins gain function in the KO samples), and events ORF-disrupted upon exclusion being included (the proteins gain function in the KO samples too).

```{r protein impact psi fmn2}

library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)      # For pairwise comparisons and p-value adjustment
library(ggpubr)       # For stat_pvalue_manual if needed

original_columns <- colnames(fmndko_unique)
# Prepare the data frame
fmn_df <- as.data.frame(fmndko_unique) %>% 
  rownames_to_column("EVENT") %>% 
  pivot_longer(
    cols = -EVENT,
    names_to = "sample",
    values_to = "value"
  ) 

# Modify dose based on sample name
fmn_df <- fmn_df %>%
  mutate(
    variable_order = match(sample, original_columns),
    group = ceiling(variable_order / 3),
    condition = case_when(
      str_detect(sample, "Control") ~ "Control",
      str_detect(sample, "KO") ~ "KO",
      TRUE ~ NA_character_
    ),
    condition = factor(condition, levels = c("Control", "KO"))  # Ensure correct order
  ) %>%
  select(-variable_order, -group)

# Assign the protein impact based on matching EventID.
fmn_df$protein_impact <- final_impact_string$ONTO[match(fmn_df$EVENT, final_impact_string$EventID)]

# Cluster the protein_impact values into desired groups
fmn_df <- fmn_df %>%
  mutate(
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disruption upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disruption upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ "Unknown"
    )
  ) %>%
  arrange(EVENT, sample, condition)

# Function to calculate bootstrap confidence intervals
bootstrap_ci <- function(values, n_bootstrap = 1000, conf_level = 0.95) {
  boot_samples <- replicate(n_bootstrap, mean(sample(values, replace = TRUE)))
  quantile(boot_samples, probs = c((1 - conf_level) / 2, 1 - (1 - conf_level) / 2))
}

# Perform pairwise paired t-tests within each protein_impact group
stat_test <- fmn_df %>%
  group_by(protein_impact) %>%
  pairwise_t_test(
    value ~ condition,
    paired = TRUE,
    p.adjust.method = "none"
  ) %>%
  ungroup() %>%
  filter(p.adj < 0.05) %>%
  mutate(signif = case_when(
    p.adj < 0.001 ~ "***",
    p.adj < 0.01  ~ "**",
    p.adj < 0.05  ~ "*"
  ))

# Compute summary statistics with bootstrapped confidence intervals
summary_df <- fmn_df %>%
  group_by(condition, protein_impact) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    ci_lower = bootstrap_ci(value)[1],
    ci_upper = bootstrap_ci(value)[2],
    .groups = "drop"
  )

# Ensure dose is a factor in stat_test
stat_test <- stat_test %>%
  mutate(
    group1 = factor(group1, levels = levels(fmn_df$condition)),
    group2 = factor(group2, levels = levels(fmn_df$condition)),
    y.position = max(fmn_df$value, na.rm = TRUE) * 1.05  # Adjusted dynamically
  )

# Set the upper y-axis limit dynamically
max_y <- max(fmn_df$value, na.rm = TRUE) * 1.1  

# Plot with refined settings
impact_psi_plot_fmn<-ggplot(summary_df, 
       aes(x = condition, y = mean_value, group = protein_impact, color = protein_impact, fill = protein_impact)) +
  geom_point(data = fmn_df, aes(x = condition, y = value), color = "grey70", alpha = 0.4, size = 1) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +
  
  # Add significance annotations
  stat_pvalue_manual(
    stat_test, 
    label = "signif",
    xmin = "group1", 
    xmax = "group2",
    y.position = "y.position",
    tip.length = 0.01,
    size = 4
  ) +

  # Facet by protein impact
  facet_wrap(~ protein_impact) +

  # Adjust x and y axes
  scale_y_continuous(limits = c(0, max_y), expand = expansion(mult = c(0.05, 0.05))) +

  # Clean and minimal theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major = element_line(color = "grey85", size = 0.3),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 12),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(size = 10)
  ) +
  
  # Labels
  labs(x = "Condition", 
       y = "Mean PSI", 
       color = "Protein Impact", 
       fill = "Protein Impact")

ggsave("final_plots/protein_impact_plot_fmn2.svg", impact_psi_plot_fmn, width = 12, height = 8)
impact_psi_plot_fmn
```


# System Settings

```{r session info}
sessionInfo()
```
