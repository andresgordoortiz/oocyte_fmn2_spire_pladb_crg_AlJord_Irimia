---
title: "Oocyte Alternative Splicing Analysis"
subtitle: "FMN2 & SPIRE1/2 KO"
author: "Andrés Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    code_download: false
    df_print: paged
    number_sections: true

editor_options:
  markdown:
    wrap: 72

header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        /* Base styling */
        body {
          font-family: "Roboto", sans-serif;
          color: #333;
          background-color: #ffffff;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 960px;
          margin: auto;
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 {
          color: #2C3E50;
          text-align: center;
          font-weight: 700;
          margin: 0.5em 0;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.75em; }
        
        /* Text styling */
        p {
          line-height: 1.6;
          margin-bottom: 1em;
          text-align: justify;
        }
        .subtitle, .author, .date {
          text-align: center;
          color: #2C3E50;
          margin-bottom: 0.5em;
        }
        
        /* Links */
        a {
          color: #0275d8;
          text-decoration: none;
        }
        a:hover {
          text-decoration: underline;
        }
        
        /* Tables */
        table {
          width: 100%;
          border-collapse: collapse;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 10px;
        }
        th {
          background-color: #2C3E50;
          color: #fff;
        }
        tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        tr:hover {
          background-color: #f1f1f1;
        }
     </style>'
---




```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")

# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"

```

# Introduction to this Analysis

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Data Acquisition**:
  - Downloading `*.fastq.gz` files of these studies:
    - **FMN2 DKO Oocytes**
    - **SPIRE1/2 DKO Oocytes**
  - Merging technical replicates for superior sequencing depth. RNA Splicing analysis usually requires a minimum of 50 million reads per biological sample.

2. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

3. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. Vast-Tools does **not** find new splicing events, relaying on a manually curated database, [VASTDB](https://vastdb.crg.eu/), with more than 600.000 splicing events. The end result is an `Inclusion_table.tab`, which contains the splicing events as rows and the samples as columns. Splicing is quantified using the Percentage Spliced-In (PSI) parameter, which shows the percentage at which a given splicing event occurs across all sequencing reads of the gene. The database covers the following splicing events:
   
     - **Exons (EX)**: Cassette sequences that are either included or excluded in the mature mRNA.
     - **Introns (IN)**: Introns that are either retained or spliced out in the mature mRNA.
     - **Alternative 5' Splice Sites (Alt5)**: Exons that are spliced at different 5' sites (donor sites).
     - **Alternative 3' Splice Sites (Alt3)**: Exons that are spliced at different 3' sites (acceptor sites).
     - **Microexons (MIC)**: Exons that are shorter than 27 nucleotides.

---

## Part 2: Statistical Analysis

State-of-Art splicing analysis tools such as the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) employ a combination of statistical testing and simulations on the *beta* distribution to calculate the delta PSI (the difference in splicing between two conditions) and the False Discovery rate (FDR, or adjusted p-value) respectively. This is computationally demanding for such a large dataset. For that reason we focused first on analyzing *alternative* splicing events (that is, events with a PSI different that *0* or *100*--not always active, not always inactive) which constitute ~25% of all events in both *FMN2* and *Spire* studies. With that first analysis done (which can be accessed completely in the file `alternative_splicing_fmn2_spire.html`) we fine-tuned the code and used the complete dataset (using both constitutive and alternative events). As expected, almost all significant events found in the smaller subset are found using it fully (see *Comparing both analysis* section below). The specific steps taken for these analysis were.


1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform Beta Distribution simulations to obtain:
     - **False Discovery Rate (FDR)**
     - **delta Percentage Spliced-in (dPSI)**

2. **Filtering Criteria**: Significant events are defined by
     - FDR <= 0.05
     - |dPSI| >= 0.1 (out of 1. That is, at least a 10% increase or decrease in PSI)

All the code history can be accessed through its [GitHub Repository](https://github.com/andresgordoortiz/24crg_adel_manu_oocyte_splicing)

---


```{r inclusion tables}

fmndko_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/fmndko_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
fmndko_events <- getEvents(fmndko_data, tool = "vast-tools") # Extract alternative splicing events

fmndko_exons <- filterEvents(fmndko_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 2)
fmndko_introns <- filterEvents(fmndko_events, types = c("IR"), N = 2)
fmndko_alt <- filterEvents(fmndko_events, types = c("Alt5", "Alt3"), N = 2)



spire_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/spiredko_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
spire_events <- getEvents(spire_data, tool = "vast-tools") # Extract alternative splicing events

spire_exons <- filterEvents(spire_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 2)
spire_introns <- filterEvents(spire_events, types = c("IR"), N = 2)
spire_alt <- filterEvents(spire_events, types = c("Alt5", "Alt3"), N = 2)


```


## Metadata { .tabset}

### FMN2DKO

```{r metadata fmn2dko}
# Load metadata file containing sample information
metadata_fmn2dko<-data.frame(samples=c("SRR6026682_SRR6026683_SRR6026684_merged","SRR6026685_SRR6026686_SRR6026687_merged","SRR6026688_SRR6026689_SRR6026690_merged","SRR6026691_SRR6026692_SRR6026693_merged"),condition=c("control","control","fmndko","fmndko"))
DT::datatable(metadata_fmn2dko, options = list(pageLength = nrow(metadata_fmn2dko), scrollX = TRUE))
```

### Spire

```{r metadata tao}
# Load metadata file containing sample information
metadata_spire<-data.frame(samples=c("Oocytes_FG_Spire12_Cont_a","Oocytes_FG_Spire12_Cont_b","Oocytes_FG_Spire12_Cont_c","Oocytes_FG_Spire12_DKO_a","Oocytes_FG_Spire12_DKO_b","Oocytes_FG_Spire12_DKO_c"), condition=rep(c("control", "spiredko"), each=3))
DT::datatable(metadata_spire, options = list(pageLength = nrow(metadata_spire), scrollX = TRUE))
```


---



# Total Splicing Events

This plot shows the total number of splicing events found during the **mapping**, alongside the proportions of each type of event. It is important to know that *vast-tools* does not find new events, but it identifies those manually curated in the database. The total number is the same for both datasets, as it is the total number of events registered and curated in ***VASTDB***, hence the *Complete Version.* 


```{r splicing events barplot stacked}

# Adjusted version of the script
splicing_events <- tibble(
  event_type = names(spire_events$EventsPerType),
  spire = spire_events$EventsPerType,
  fmndko = fmndko_events$EventsPerType
)

splicing_events_long <- splicing_events %>%
  pivot_longer(cols = c(spire, fmndko),
               names_to = "study", values_to = "count") %>%
  mutate(event_type = ifelse(event_type %in% c("C1", "C2", "C3", "ANN", "S", "MIC"), "EX", event_type)) %>%
  group_by(study, event_type) %>%
  summarize(count = sum(count, na.rm = TRUE), .groups = "drop")

# Proportion bar plot
plot_proportion <- ggplot(splicing_events_long, aes(fill = event_type, y = count, x = study)) +
  geom_bar(position = "fill", stat = "identity") +
  labs(
    title = "<b style='font-size:18px;'>Proportion of Splicing Events by Study</b>",
    x = NULL,
    y = "Proportion of Events",
    fill = "Event Type"
  ) +
  theme_minimal(base_family = font) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    plot.title = element_markdown(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5)
  ) +
  scale_fill_paletteer_d("MetBrewer::Hokusai3")

splicing_events_long_sum<-splicing_events_long %>%
  dplyr::group_by(study) %>%
  summarize(count = sum(count))


# Absolute counts plot
plot_absolute <- ggplot(splicing_events_long_sum, aes(y = count, x = study)) +
  geom_point(color = "#C70039", size = 3) +
  geom_text(aes(label = count), vjust = -1, size = 4, check_overlap = TRUE) +
  labs(
    x = "Study",
    y = "Number of Events",
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = font) +
  theme(
    legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text( size=15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3)
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.2)))


# Combine plots
combined_plot <- plot_proportion / plot_absolute +
  plot_layout(heights = c(1, 0.5)) &
  theme(plot.margin = margin(5,5, 0, 5))

ggsave("events_mapped.svg", plot = combined_plot, width = 10, height = 6, units = "in", dpi = 300)

# Display combined plot
combined_plot
```

```{r general stats}
vastdb_events<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
bin_exons <- function(n) {
  if (is.na(n)) return(NA) # Handle missing values
  else if (n < 6) return("1-5")
  else if (n < 9) return("6-10")
  else if (n < 21) return("11-20")
  else return("21+")
}

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_exons<-vastdb_events[grep("EX", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$exon_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_exons<-apply_bin_exons(vastdb_exons)

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_introns<-vastdb_events[grep("IN", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$intron_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_introns<-apply_bin_exons(vastdb_introns)

```

# Inclusion or Exclusion Plots { .tabset}

These plots show the distribution of the splicing change (dPSI) comparing the KO mutant vs the control. If there is a tendency towards inclusion or exclusion, the bell-shaped curve will be shifted to the right or left, respectively. First, I calculated the mean of each event per condition and then I calculated the difference between means for each event. The subtitle shows the Wilcoxon test assessing this possible asymmetry. The area under the curve for both sides (>0 and <0) is shown numerically. Only events with a dPSI greater or lower than 0 are shown for clarity.

## Exons 

### Spire

```{r inclusionumber of exons spire}
# ---- Prepare Data -----------------------------------------------------------
# Remove any NA rows (adjust as needed)
spire_exons_df <- na.omit(spire_exons$PSI)

# Function to compute the PSI difference for each row (KO - Control)
compute_difference <- function(df) {
  avg_KO <- rowMeans(df[, 10:12])
  avg_control <- rowMeans(df[, 7:9])
  avg_KO - avg_control
}

# Calculate the difference and remove any additional NAs
spire_exons_df$difference <- compute_difference(spire_exons_df)
spire_exons_df <- na.omit(spire_exons_df)

# Create a group variable based on whether the difference is below or above zero
spire_exons_df$group <- ifelse(spire_exons_df$difference < 0, "Skipped", "Included")

# Perform a one-sample Wilcoxon signed-rank test (null hypothesis: median = 0)
symmetry_test <- wilcox.test(spire_exons_df$difference, mu = 0)

# Compute the percentages (areas under the density curve)
pct_below <- round(mean(spire_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(spire_exons_df$difference > 0) * 100, 1)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  spire_exons_df[abs(spire_exons_df$difference) > 0, ], 
  aes(x = difference, fill = group)
) +
  geom_histogram(aes(y = ..density..), bins = 200, 
                 position = "identity", alpha = 0.9) +
  labs(
    title = "PSI Difference Distribution of Exons in Spire",
    subtitle = paste("One-sample Wilcoxon test p-value for Symmetry:", 
                     format(symmetry_test$p.value, digits = 3)),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("dPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "blue", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("dPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "red", size = 7, fontface = "bold",
           label.size = 0.5) +
  scale_fill_brewer(palette = "Set1")

# Save and display the plot
ggsave("spire_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)

```



### FMN2

```{r inclusionumber of exons fmndko}
# ---- Prepare Data -----------------------------------------------------------
# Remove any NA rows (adjust as needed)
fmndko_exons_df <- na.omit(fmndko_exons$PSI)

# Function to compute the PSI difference for each row (KO - Control)
compute_difference <- function(df) {
  avg_KO <- rowMeans(df[, 9:10])
  avg_control <- rowMeans(df[, 7:8])
  avg_KO - avg_control
}

# Calculate the difference and remove any additional NAs
fmndko_exons_df$difference <- compute_difference(fmndko_exons_df)
fmndko_exons_df <- na.omit(fmndko_exons_df)

# Create a group variable based on whether the difference is below or above zero
fmndko_exons_df$group <- ifelse(fmndko_exons_df$difference < 0, "Skipped", "Included")

# Perform a one-sample Wilcoxon signed-rank test (null hypothesis: median = 0)
symmetry_test <- wilcox.test(fmndko_exons_df$difference, mu = 0)

# Compute the percentages (areas under the density curve)
pct_below <- round(mean(fmndko_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(fmndko_exons_df$difference > 0) * 100, 1)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  fmndko_exons_df[abs(fmndko_exons_df$difference) > 0, ], 
  aes(x = difference, fill = group)
) +
  geom_histogram(aes(y = ..density..), bins = 200, 
                 position = "identity", alpha = 0.9) +
  labs(
    title = "PSI Difference Distribution of Exons in FMN2",
    subtitle = paste("One-sample Wilcoxon test p-value for Symmetry:", 
                     format(symmetry_test$p.value, digits = 3)),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("dPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "blue", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("dPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "red", size = 7, fontface = "bold",
           label.size = 0.5) +
  scale_fill_brewer(palette = "Set1")

# Save and display the plot
ggsave("fmn2_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)
print(plot_psi_distribution)

```

## Introns

### Spire

```{r inclusionumber of introns spire}
# ---- Prepare Data -----------------------------------------------------------
# Remove any NA rows (adjust as needed)
spire_introns_df <- na.omit(spire_introns$PSI)

# Function to compute the PSI difference for each row (KO - Control)
compute_difference <- function(df) {
  avg_KO <- rowMeans(df[, 10:12])
  avg_control <- rowMeans(df[, 7:9])
  avg_KO - avg_control
}

# Calculate the difference and remove any additional NAs
spire_introns_df$difference <- compute_difference(spire_introns_df)
spire_introns_df <- na.omit(spire_introns_df)

# Create a group variable based on whether the difference is below or above zero
spire_introns_df$group <- ifelse(spire_introns_df$difference < 0, "Skipped", "Included")

# Perform a one-sample Wilcoxon signed-rank test (null hypothesis: median = 0)
symmetry_test <- wilcox.test(spire_introns_df$difference, mu = 0)

# Compute the percentages (areas under the density curve)
pct_below <- round(mean(spire_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(spire_introns_df$difference > 0) * 100, 1)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  spire_introns_df[abs(spire_introns_df$difference) > 0, ], 
  aes(x = difference, fill = group)
) +
  geom_histogram(aes(y = ..density..), bins = 200, 
                 position = "identity", alpha = 0.9) +
  labs(
    title = "PSI Difference Distribution of Introns in Spire",
    subtitle = paste("One-sample Wilcoxon test p-value for Symmetry:", 
                     format(symmetry_test$p.value, digits = 3)),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("dPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "blue", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("dPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "red", size = 7, fontface = "bold",
           label.size = 0.5) +
  scale_fill_brewer(palette = "Set1")

# Save and display the plot
ggsave("spire_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)


```

### FMN2

```{r inclusionumber of introns fmndko}
# ---- Prepare Data -----------------------------------------------------------
# Remove any NA rows (adjust as needed)
fmndko_introns_df <- na.omit(fmndko_introns$PSI)

# Function to compute the PSI difference for each row (KO - Control)
compute_difference <- function(df) {
  avg_KO <- rowMeans(df[, 9:10])
  avg_control <- rowMeans(df[, 7:8])
  avg_KO - avg_control
}

# Calculate the difference and remove any additional NAs
fmndko_introns_df$difference <- compute_difference(fmndko_introns_df)
fmndko_introns_df <- na.omit(fmndko_introns_df)

# Create a group variable based on whether the difference is below or above zero
fmndko_introns_df$group <- ifelse(fmndko_introns_df$difference < 0, "Skipped", "Included")

# Perform a one-sample Wilcoxon signed-rank test (null hypothesis: median = 0)
symmetry_test <- wilcox.test(fmndko_introns_df$difference, mu = 0)

# Compute the percentages (areas under the density curve)
pct_below <- round(mean(fmndko_introns_df$difference < 0) * 100, 1)
pct_above <- round(mean(fmndko_introns_df$difference > 0) * 100, 1)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  fmndko_introns_df[abs(fmndko_introns_df$difference) > 0, ], 
  aes(x = difference, fill = group)
) +
  geom_histogram(aes(y = ..density..), bins = 200, 
                 position = "identity", alpha = 0.9) +
  labs(
    title = "PSI Difference Distribution of Introns in FMN2",
    subtitle = paste("One-sample Wilcoxon test p-value for Symmetry:", 
                     format(symmetry_test$p.value, digits = 3)),
    x = "ΔPSI (KO - Control)",
    y = "Density",
    fill = "Splicing Direction",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("dPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "blue", size = 7, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("dPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "red", size = 7, fontface = "bold",
           label.size = 0.5) +
  scale_fill_brewer(palette = "Set1")

# Save and display the plot
ggsave("fmn2_introns_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)

```




# PCA Plot { .tabset}


## Spire

```{r pca calculation spire}
# Subset and scale data
pca_spire <- spire_data[, c("EVENT",spire_events$Samples)] %>%
  na.omit()

rownames(pca_spire)<- pca_spire$EVENT
pca_spire<-t(pca_spire[,-1])


pca_result_spire <- prcomp(pca_spire)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result_spire$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_spire$condition
```

```{r pca plotting spire}
# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition), )) +
  geom_point(size = 6) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result_spire)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result_spire)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = "roboto") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_blank()
  ) +
  scale_colour_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()

pca_plot

```


## FMN2

```{r pca calculation fmndko}
# Subset and scale data
pca_fmndko <- fmndko_data[, c("EVENT",fmndko_events$Samples)] %>%
  na.omit()

rownames(pca_fmndko)<- pca_fmndko$EVENT
pca_fmndko<-t(pca_fmndko[,-1])


pca_result_fmndko <- prcomp(pca_fmndko)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result_fmndko$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-metadata_fmn2dko$condition
```

```{r pca plotting fmndko}
# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition), )) +
  geom_point(size = 6) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result_fmndko)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result_fmndko)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = "roboto") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_blank()
  ) +
  scale_colour_paletteer_d("MetBrewer::Hokusai3") +
  coord_fixed()

pca_plot

```




# Exon Lists

```{r aux_featuregroup}
# Extract unique groups and sample IDs

# fmn2dko

metadata_fmn2dko<-data.frame(samples=c("SRR6026682_SRR6026683_SRR6026684_merged","SRR6026685_SRR6026686_SRR6026687_merged","SRR6026688_SRR6026689_SRR6026690_merged","SRR6026691_SRR6026692_SRR6026693_merged"),condition=c("control","control","fmndko","fmndko"))
groups_fmndko <- unique(metadata_fmn2dko[, "condition"])
samples_fmndko <- metadata_fmn2dko$samples

# spiredko

groups_spire <- unique(metadata_spire[, "condition"])
samples_spire <- metadata_spire$samples


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")


# Create group list with metadata
groupList_fmndko <- lapply(1:length(groups_fmndko), function(i) {
  list(
    name = groups_fmndko[i],
    samples = samples_fmndko[metadata_fmn2dko[, "condition"] == groups_fmndko[i]],
    color = random_colors[i]
  )
})
names(groupList_fmndko) <- groups_fmndko

# Create group list with metadata
groupList_spire <- lapply(1:length(groups_spire), function(i) {
  list(
    name = groups_spire[i],
    samples = samples_spire[metadata_spire[, "condition"] == groups_spire[i]],
    color = random_colors[i]
  )
})
names(groupList_spire) <- groups_spire

```

```{r groups_auxiliary}
# Define groups

groupA_fmndko<-"control"
groupB_fmndko<-"fmndko"

groupA_spire<-"control"
groupB_spire<-"spiredko"


samplesA_fmndko <- groupList_fmndko[[groupA_fmndko]]$samples
samplesB_fmndko <- groupList_fmndko[[groupB_fmndko]]$samples
colsGroupA_fmndko <- convertCols(fmndko_exons$PSI, samplesA_fmndko)
colsGroupB_fmndko <- convertCols(fmndko_exons$PSI, samplesB_fmndko)

samplesA_spire <- groupList_spire[[groupA_spire]]$samples
samplesB_spire <- groupList_spire[[groupB_spire]]$samples
colsGroupA_spire <- convertCols(spire_exons$PSI, samplesA_spire)
colsGroupB_spire <- convertCols(spire_exons$PSI, samplesB_spire)


set.seed(42) #Setting seed for downstream simulations of the beta distribution
```

## Calculations

```{r pdiff calculation exons}

# Prepare table for fmn2dko
fmndko_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = fmndko_exons$PSI,
  qualtable = fmndko_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_fmndko,
  colsB = colsGroupB_fmndko,
  labA = groupA_fmndko,
  labB = groupB_fmndko,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for spire
spire_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = spire_exons$PSI,
  qualtable = spire_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_spire,
  colsB = colsGroupB_spire,
  labA = groupA_spire,
  labB = groupB_spire,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

differential_spire_exons<-na.omit(spire_pdiff_exons[spire_pdiff_exons$FDR <= 0.05 & abs(spire_pdiff_exons$deltapsi) >= 0.1,])
differential_fmndko_exons<-na.omit(fmndko_pdiff_exons[fmndko_pdiff_exons$FDR <= 0.05 & abs(fmndko_pdiff_exons$deltapsi) >= 0.1,])

shared_exons<-differential_spire_exons$EVENT[differential_spire_exons$EVENT %in% differential_fmndko_exons$EVENT]

write.csv(fmndko_pdiff_exons,"fmndko_pdiff_exons.csv")
write.csv(spire_pdiff_exons,"spire_pdiff_exons.csv")
```




## Volcano Plots { .tabset}


### FMN2

```{r fmndko fdr volcano exons}

library(ggrepel)
fmndko_pdiff_exons<-na.omit(fmndko_pdiff_exons)
# Add a Shared column based on the shared_exons
fmndko_pdiff_exons$Shared <- ifelse(fmndko_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
fmndko_pdiff_exons$Significant <- ifelse(
  fmndko_pdiff_exons$FDR <=0.05 & fmndko_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    fmndko_pdiff_exons$FDR <=0.05 & fmndko_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
fmndko_pdiff_exons$negLogpvalue <- -log10(fmndko_pdiff_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
fmndko_pdiff_exons <- fmndko_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(fmndko_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(fmndko_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(fmndko_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

### Spire

```{r spire fdr volcano exons}
spire_pdiff_exons<-na.omit(spire_pdiff_exons)
# Add a Shared column based on the shared_exons
spire_pdiff_exons$Shared <- ifelse(spire_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
spire_pdiff_exons$Significant <- ifelse(
  spire_pdiff_exons$FDR <=0.05 & spire_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    spire_pdiff_exons$FDR <=0.05 & spire_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
spire_pdiff_exons$negLogpvalue <- -log10(spire_pdiff_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
spire_pdiff_exons <- spire_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(spire_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(spire_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(spire_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_exons.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot


```


## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 



### FMN2

```{r fmndko combination table exons}
# Render DataTable with enhancements
datatable(
  differential_fmndko_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spire


```{r spire combination table exons}
# Render DataTable with enhancements
datatable(
  differential_spire_exons,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```



# Intron Lists

## Calculations

```{r pdiff calculation introns}


# Prepare table for Tao
fmndko_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = fmndko_introns$PSI,
  qualtable = fmndko_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_fmndko,
  colsB = colsGroupB_fmndko,
  labA = groupA_fmndko,
  labB = groupB_fmndko,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for spire
spire_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = spire_introns$PSI,
  qualtable = spire_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_spire,
  colsB = colsGroupB_spire,
  labA = groupA_spire,
  labB = groupB_spire,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

differential_spire_introns<-na.omit(spire_pdiff_introns[spire_pdiff_introns$FDR <=0.05 & abs(spire_pdiff_introns$deltapsi)>=0.1,])
differential_fmndko_introns<-na.omit(fmndko_pdiff_introns[fmndko_pdiff_introns$FDR <=0.05 & abs(fmndko_pdiff_introns$deltapsi)>=0.1,])



shared_introns<-differential_spire_introns$EVENT[differential_spire_introns$EVENT %in% differential_fmndko_introns$EVENT]

write.csv(fmndko_pdiff_introns,"fmndko_pdiff_introns.csv")
write.csv(spire_pdiff_introns,"spire_pdiff_introns.csv")

```



## Volcano Plots { .tabset}


### FMN2

```{r fmndko volcano introns}
fmndko_pdiff_introns<-na.omit(fmndko_pdiff_introns)
# Add a Shared column based on the shared_exons
fmndko_pdiff_introns$Shared <- ifelse(fmndko_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
fmndko_pdiff_introns$Significant <- ifelse(
  fmndko_pdiff_introns$FDR <=0.05 & fmndko_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    fmndko_pdiff_introns$FDR <=0.05 & fmndko_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
fmndko_pdiff_introns$negLogpvalue <- -log10(fmndko_pdiff_introns$FDR)


# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
fmndko_pdiff_introns <- fmndko_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(fmndko_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(fmndko_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(fmndko_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

### Spire

```{r spire volcano introns}
spire_pdiff_introns<-na.omit(spire_pdiff_introns)
spire_pdiff_introns$Shared <- ifelse(spire_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
spire_pdiff_introns$Significant <- ifelse(
  spire_pdiff_introns$FDR <=0.05 & spire_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    spire_pdiff_introns$FDR <=0.05 & spire_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
spire_pdiff_introns$negLogpvalue <- -log10(spire_pdiff_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
spire_pdiff_introns <- spire_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(spire_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(spire_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(spire_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_introns.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 

### FMN2



```{r fmndko combination table introns}
# Render DataTable with enhancements
datatable(
  differential_fmndko_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spire


```{r spire combination table introns}
# Render DataTable with enhancements
datatable(
  differential_spire_introns,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```


# Alternative 5´ & 3´

## Calculations

```{r pdiff calculation alt}

# Prepare table for Tao
fmndko_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = fmndko_alt$PSI,
  qualtable = fmndko_alt$Qual,
  npoints = 500,
  colsA = colsGroupA_fmndko,
  colsB = colsGroupB_fmndko,
  labA = groupA_fmndko,
  labB = groupB_fmndko,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for spire
spire_pdiff_alt <- prepareTableVolcanoFDR(
  psitable = spire_alt$PSI,
  qualtable = spire_alt$Qual,
  npoints = 500,
  colsA = colsGroupA_spire,
  colsB = colsGroupB_spire,
  labA = groupA_spire,
  labB = groupB_spire,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

differential_spire_alt<-na.omit(spire_pdiff_alt[spire_pdiff_alt$FDR <=0.05 & abs(spire_pdiff_alt$deltapsi)>=0.1 ,])
differential_fmndko_alt<-na.omit(fmndko_pdiff_alt[fmndko_pdiff_alt$FDR <=0.05 & abs(fmndko_pdiff_alt$deltapsi)>=0.1 ,])

shared_alt<-differential_spire_alt$EVENT[differential_spire_alt$EVENT %in% differential_fmndko_alt$EVENT]

write.csv(fmndko_pdiff_alt,"fmndko_pdiff_alt.csv")
write.csv(spire_pdiff_alt,"spire_pdiff_alt.csv")
```




## Volcano Plots { .tabset}


### FMN2

```{r fmndko  volcano alt}
fmndko_pdiff_alt<-na.omit(fmndko_pdiff_alt)
fmndko_pdiff_alt$Shared <- ifelse(fmndko_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
fmndko_pdiff_alt$Significant <- ifelse(
  fmndko_pdiff_alt$FDR <=0.05 & fmndko_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    fmndko_pdiff_alt$FDR <=0.05 & fmndko_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
fmndko_pdiff_alt$negLogpvalue <- -log10(fmndko_pdiff_alt$FDR)
# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
fmndko_pdiff_alt <- fmndko_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(fmndko_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(fmndko_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(fmndko_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

### Spire

```{r spire fdr volcano alt}
spire_pdiff_alt<-na.omit(spire_pdiff_alt)
spire_pdiff_alt$Shared <- ifelse(spire_pdiff_alt$EVENT %in% shared_alt, "Shared", "Not Shared")

# Classify significance
spire_pdiff_alt$Significant <- ifelse(
  spire_pdiff_alt$FDR <=0.05 & spire_pdiff_alt$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    spire_pdiff_alt$FDR <=0.05 & spire_pdiff_alt$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
spire_pdiff_alt$negLogpvalue <- -log10(spire_pdiff_alt$FDR)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
spire_pdiff_alt <- spire_pdiff_alt %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(spire_pdiff_alt, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(spire_pdiff_alt, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(spire_pdiff_alt, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire Alt 5´ 3´",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )



# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_alt.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

## Individual Combination Tables { .tabset}

These tables show the introns with FDR <= 0.05 and |dPSI|>=0.1 in the pairwise comparison of each condition. 


### FMN2


```{r fmndko combination table alt}
# Render DataTable with enhancements
datatable(
  differential_fmndko_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

### Spire



```{r spire combination table alt}
# Render DataTable with enhancements
datatable(
  differential_spire_alt,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "FDR",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```

# All Event Types Volcano Plots { .tabset}


## FMN2

```{r fmndko all volcano }

mega_volcano<-rbind(fmndko_pdiff_alt,fmndko_pdiff_exons,fmndko_pdiff_introns)

max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of FMN2 All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_fmndko_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)
ggsave("volcano_fmndko_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 120)

volcano_plot
```

## Spire

```{r spire fdr volcano all}
mega_volcano<-rbind(spire_pdiff_alt,spire_pdiff_exons,spire_pdiff_introns)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
mega_volcano <- mega_volcano %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(mega_volcano, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(mega_volcano, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(mega_volcano, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#E00E73",
    "Underrepresented" = "#3E2672",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (KO - WT)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Spire All Events",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14, base_family = "Arial") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Save as SVG with dimensions 606 x 396
ggsave("volcano_spire_all_events.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)
ggsave("volcano_spire_all_events.png", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 120)

volcano_plot
```

# Comparing both Analysis

The following table compares the results of the two analyses: the one using the complete dataset (this report) or the simpler one, only using alternative events. The more complete analysis finds more significant (FDR <= 0.05 & |dPSI| >= 0.1) splicing events. It also preserves all of those found by the simpler analysis. 

```{r comparison}
old_spire_exons<-filter(read.csv("versionA_lists/exon_spire.csv")[,-1], FDR<=0.05, abs(deltapsi)>=0.1)
old_fmndko_exons<-filter(read.csv("versionA_lists/exon_fmndko.csv")[,-1], FDR<=0.05, abs(deltapsi)>=0.1)
old_spire_introns<-filter(read.csv("versionA_lists/intron_spire.csv")[,-1], FDR<=0.05, abs(deltapsi)>=0.1)
old_fmndko_introns<-filter(read.csv("versionA_lists/intron_fmndko.csv")[,-1], FDR<=0.05, abs(deltapsi)>=0.1)
old_spire_alt<-filter(read.csv("versionA_lists/alt_spire.csv")[,-1], FDR<=0.05, abs(deltapsi)>=0.1)
old_fmndko_alt<-filter(read.csv("versionA_lists/alt_fmndko.csv")[,-1], FDR<=0.05, abs(deltapsi)>=0.1)

compare_table<-data.frame(study=c("FMN2 (alternative/complete)", "Spire (alternative/complete)"), number_exons=c(paste0(length(unique(old_fmndko_exons$EVENT)),"/",length(unique(differential_fmndko_exons$EVENT))), paste0(length(unique(old_spire_exons$EVENT)),"/",length(unique(differential_spire_exons$EVENT)))), number_introns=c(paste0(length(unique(old_fmndko_introns$EVENT)),"/",length(unique(differential_fmndko_introns$EVENT))), paste0(length(unique(old_spire_introns$EVENT)),"/",length(unique(differential_spire_introns$EVENT)))), number_alt=c(paste0(length(unique(old_fmndko_alt$EVENT)),"/",length(unique(differential_fmndko_alt$EVENT))), paste0(length(unique(old_spire_alt$EVENT)),"/",length(unique(differential_spire_alt$EVENT)))), overlapping=c(paste0(round(mean(c(old_fmndko_exons$EVENT,old_fmndko_introns$EVENT,old_fmndko_alt$EVENT) %in% c(differential_fmndko_exons$EVENT,differential_fmndko_introns$EVENT,differential_fmndko_alt$EVENT))*100, digits = 1), "%"), paste0(round(mean(c(old_spire_exons$EVENT,old_spire_introns$EVENT,old_spire_alt$EVENT) %in% c(differential_spire_exons$EVENT,differential_spire_introns$EVENT,differential_spire_alt$EVENT))*100, digits = 1), "%")))


compare_table <- compare_table %>%
  rename(
    "Significant Exons" = number_exons,
    "Significant Introns" = number_introns,
    "Significant Alt 5´ 3´" = number_alt,
    "Overlapping"=overlapping
  )

datatable(compare_table)
```

# Basic Stats on Found Events

## Events-level stats

```{r basic stats}

# Define study-specific data
fmndko_exons <- data.frame(EVENT = differential_fmndko_exons$EVENT, Type = "Exons", Study = "FMN2")
fmndko_introns <- data.frame(EVENT = differential_fmndko_introns$EVENT, Type = "Introns", Study = "FMN2")
fmndko_alt <- data.frame(EVENT = differential_fmndko_alt$EVENT, Type = "Alt", Study = "FMN2")

spire_exons <- data.frame(EVENT = differential_spire_exons$EVENT, Type = "Exons", Study = "Spire")
spire_introns <- data.frame(EVENT = differential_spire_introns$EVENT, Type = "Introns", Study = "Spire")
spire_alt <- data.frame(EVENT = differential_spire_alt$EVENT, Type = "Alt", Study = "Spire")

# Combine all events into one dataframe
all_events <- bind_rows(fmndko_exons, fmndko_introns, fmndko_alt, spire_exons, spire_introns, spire_alt)

# Determine whether the event appears in both studies
event_counts <- all_events %>%
  group_by(EVENT, Type) %>%
  summarize(Appearance = ifelse(n() > 1, "Both Studies", "Single Study"), .groups = "drop")

# Merge back to the original dataset
all_events <- all_events %>%
  left_join(event_counts, by = c("EVENT", "Type"))

# Create the bar plot
p <- ggplot(all_events, aes(x = Study, fill = Appearance)) +
  geom_bar(position = "stack") +
  facet_wrap(~Type) +
  theme_minimal(base_size = 16, base_family = "sans") +
  scale_fill_manual(values = c("Both Studies" = "#4E79A7", "Single Study" = "#F28E2B")) +  # Nicer colors
  labs(
    title = "Comparison of Differentially Spliced Events in FMN2 and Spire",
    x = "Study",
    y = "Count of Events",
    fill = "Event Presence"
  ) +
  theme(
    legend.position = "top",
    strip.text = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    panel.grid = element_blank(),  # Remove grid lines
    panel.background = element_blank(),  # Remove background color
    axis.line = element_line(color = "black") 
      # Add axis lines for clarity
  )

ggsave("basic_stats_events.svg", p, width = 12, height = 6, units = "in", dpi = 300)

# Display the plot
print(p)

```

## Gene-level stats

```{r, basic gene stats}
# Define study-specific data
fmndko_stats <- data.frame(GENE = unique(c(differential_fmndko_exons$GENE,differential_fmndko_introns$GENE,differential_fmndko_alt$GENE)), Study = "FMN2")

spire_stats <- data.frame(GENE = unique(c(differential_spire_exons$GENE,differential_spire_introns$GENE,differential_spire_alt$GENE)),  Study = "Spire")


# Combine all genes into one dataframe
all_genes <- bind_rows(fmndko_stats, spire_stats)

# Determine whether the gene appears in both studies
gene_counts <- all_genes %>%
  group_by(GENE) %>%
  summarize(Appearance = ifelse(n() > 1, "Both Studies", "Single Study"), .groups = "drop")

shared_genes<-gene_counts$GENE[gene_counts$Appearance=="Both Studies"]

# Merge back to the original dataset
all_genes <- all_genes %>%
  left_join(gene_counts, by = c("GENE"))

# Create the bar plot
p <- ggplot(all_genes, aes(x = Study, fill = Appearance)) +
  geom_bar(position = "stack") +
  theme_minimal(base_size = 16, base_family = "sans") +
  scale_fill_manual(values = c("Both Studies" = "#4E79A7", "Single Study" = "#F28E2B")) +  # Nicer colors
  labs(
    title = "Comparison of Differentially Spliced Genes in FMN2 and Spire",
    x = "Study",
    y = "Count of Genes",
    fill = "Gene Presence"
  ) +
  theme(
    legend.position = "top",
    strip.text = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    panel.grid = element_blank(),  # Remove grid lines
    panel.background = element_blank(),  # Remove background color
    axis.line = element_line(color = "black")  # Add axis lines for clarity
  )


ggsave("basic_stats_genes.svg", p, width = 10, height = 6, units = "in", dpi = 300)
# Display the plot
print(p)

```


# Enrichment Analysis with EnrichR { .tabset}

The following ontology analysis uses all significant events regardless of type.

### FMN2 { .tabset}

```{r fmndko enrichr}
enrichdata<-enrichr(unique(c(differential_fmndko_exons$GENE, differential_fmndko_introns$GENE, differential_fmndko_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```


#### GO Biological Process

```{r fmndko bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r fmndko cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])

datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r fmndko molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])

rna_fmndko_genes <- unlist(strsplit(
  enrichdata[[3]]$Genes[grepl("GO:0003723", enrichdata[[3]]$Term)], 
  split = ";"
))


datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

### Spire { .tabset}

```{r spire enrichr}
enrichdata<-enrichr(unique(c(differential_spire_exons$GENE, differential_spire_introns$GENE, differential_spire_alt$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))


```

#### GO Biological Process

```{r spire bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r spire cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r spire molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```



# Gene-centric Analysis { .tabset}

The following analysis identifies the number of significant events a given gene has. This number of *hits* serves as a proxy of how heavily influenced by splicing a given gene has been. The table shows how many genes classified by the number of significant events I have found, alongside the proportion of ORF disruption for each group. The plot then shows the list of genes, with at least 3 *hits*, in the x-axis, their average |dPSI| in the y-axis, and the shape of the points shows whether that given event is ORF-disrupted.

## FMN2

```{r gene-centric plot fmn2 prep}
# Set seed for reproducibility
set.seed(44)

# -------------------------------
# 0. Read protein impact data and combine your events
# -------------------------------
protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, 
                             fill = TRUE, quote = "")

# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_fmndko_exons,
  introns = differential_fmndko_introns,
  alt = differential_fmndko_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r fmn2 gene-centric plot, fig.width=24, fig.height=10}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.6) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in FMN2",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("fmn2_splicing_events_plot.svg", plot = p2, width = 24, height = 10, dpi = 300)

# Display the plot
print(p2)
```


## Spire

```{r gene-centric plot spire prep}
# Set seed for reproducibility
set.seed(44)



# Combine exon and intron event data (with a column "source" indicating the origin)
combined_df <- bind_rows(
  exons  = differential_spire_exons,
  introns = differential_spire_introns,
  alt = differential_spire_alt,
  .id = "source"
)

# Add protein impact info by matching on event IDs
combined_df$protein_impact <- protein_impact$ONTO[match(combined_df$EVENT, protein_impact$EventID)]

# Keep one row per EVENT (if duplicates exist)
combined_df <- combined_df %>% distinct(EVENT, .keep_all = TRUE) %>%
  filter(!GENE == "")

# -------------------------------
# 1. Create per-gene summary statistics
# -------------------------------
combined_df_summary <- combined_df %>%
  distinct(GENE, EVENT, .keep_all = TRUE) %>%  # remove duplicate gene/event rows if any
  group_by(GENE) %>%
  summarise(
    nEvents   = n(),                                        # number of events per gene
    meanDelta = mean(abs(deltapsi), na.rm = TRUE),          # mean absolute |dPSI|
    sdDelta   = sd(abs(deltapsi), na.rm = TRUE)             # standard deviation (for reference)
  ) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%              # sort: genes with more events first
  mutate(GENE = factor(GENE, levels = unique(GENE)))        # set ordering for later plotting

# -------------------------------
# 2. Add ORF information to gene-level summary
#    (We consider a gene “ORF disrupted” if any of its events has impact labeled as "ORF")
# -------------------------------
# First, mark each event as ORF or Non-ORF
combined_df <- combined_df %>%
  mutate(
    absDelta = abs(deltapsi),
    impact   = ifelse(grepl("ORF", protein_impact, ignore.case = TRUE), "ORF", "Non-ORF")
  ) 

# Compute per-gene flag: Does the gene have at least one ORF event?
gene_ORF_flag <- combined_df %>%
  group_by(GENE) %>%
  summarise(has_ORF = any(impact == "ORF"))

# Now merge with the gene summary
combined_df_summary <- combined_df_summary %>%
  left_join(gene_ORF_flag, by = "GENE")

# -------------------------------
# 3. Create a summary table (datatable) grouped by number of events per gene
#    Showing for each nEvents the number of genes and the proportion that are ORF disrupted
# -------------------------------
table_summary <- combined_df_summary %>%
  group_by(nEvents) %>%
  summarise(
    n_genes  = n(),
    prop_ORF = paste0(round(mean(has_ORF), 3)*100, "%")  # proportion of genes with at least one ORF event
  )


table_summary <- table_summary %>%
  rename(
    "Number of Significant Events" = nEvents,
    "Number of Genes" = n_genes,
    "Proportion of ORF" = prop_ORF
  )

# (Optional) If you want an interactive table, use DT:
datatable(table_summary, 
          rownames = FALSE,
          caption = 'Summary of Genes by Number of significant Events')
```

```{r spire gene-centric plot, fig.width=30, fig.height=12}
# -------------------------------
# Filter for genes with >2 events and compute SD
# -------------------------------
df_summary_gt2 <- combined_df_summary %>%
  filter(nEvents > 2) %>%
  arrange(desc(nEvents), desc(meanDelta)) %>%
  mutate(
    GENE = factor(GENE, levels = unique(GENE))
  )

# -------------------------------
# Build the publication-ready plot:
# - Bars show the mean |dPSI| per gene.
# - Upper error bars show mean + SD.
# -------------------------------

p2 <- ggplot(df_summary_gt2, aes(x = GENE, y = meanDelta, fill = factor(nEvents))) +
  # Bar plot for mean |dPSI|
  geom_bar(stat = "identity", width = 0.7, alpha = 0.8) +
  # Upper error bar: from meanDelta to meanDelta + SD
  geom_errorbar(aes(ymin = meanDelta, ymax = meanDelta + sdDelta),
                width = 0.2, color = "black", alpha = 0.7) +
  # Define fill colors (using a color palette) and label for the legend
  scale_fill_brewer(palette = "Set2", name = "Number of Events") +
  # Improved axis and plot annotations
  labs(
    x = "Gene ID",
    y = "Mean |dPSI|",
    title = "Genes with >2 Differential Splicing Events in Spire",
    subtitle = "Bar height = mean |dPSI|; Upper error bar = SD"
  ) +
  # Use a clean, publication-ready theme with custom font settings
  theme_classic(base_size = 16, base_family = "sans") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 12),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.title = element_text(face = "bold"),
    plot.margin = margin(10, 10, 10, 20) # Ensure enough space
  )

# -------------------------------
# Save the plot as an SVG
# -------------------------------
ggsave("spire_splicing_events_plot.svg", plot = p2, width = 30, height = 12, dpi = 300)

# Display the plot
print(p2)
```



# Splicing Dynamics Heatmap Spire


```{r heatmap pre-prep, results='hide', fig.show='hide'}

# Extract all events
spire_all <- filterEvents(
  spire_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR","Alt3","Alt5"),
  N = 3
)
```

```{r heatmap prep, results='hide', fig.show='hide'}
set.seed(44)

spire_unique <- spire_all$PSI %>% distinct(EVENT, .keep_all = TRUE) 

spire_unique<-spire_unique[-which(is.na(spire_unique$EVENT)),]
# Set rownames and convert to matrix
rownames(spire_unique) <- spire_unique$EVENT
spire_unique <- as.matrix(spire_unique[,7:12])

# Filter rows based on the final event lists and with abs(deltapsi)>=0.1
filtered_events <- unique(c(
  differential_spire_exons[abs(differential_spire_exons$deltapsi)>=0.1, "EVENT"],
  differential_spire_introns[abs(differential_spire_introns$deltapsi)>=0.1, "EVENT"]
  ))
spire_unique <- spire_unique[rownames(spire_unique) %in% filtered_events, ]

# Create a dendrogram for the columns
col_dend <- hclust(dist(t(spire_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2) # Color branches with 3 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(spire_unique))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-8


reference_table<-data.frame(EVENT=c(differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi)>=0.1, "EVENT"],differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi)>=0.1, "EVENT"],differential_spire_exons[abs(differential_spire_exons$deltapsi)>=0.1, "EVENT"],differential_spire_introns[abs(differential_spire_introns$deltapsi)>=0.1, "EVENT"]), GENE=c(differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi)>=0.1, "GENE"],differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi)>=0.1, "GENE"],differential_spire_exons[abs(differential_spire_exons$deltapsi)>=0.1, "GENE"],differential_spire_introns[abs(differential_spire_introns$deltapsi)>=0.1, "GENE"]))



ht<-Heatmap(
  spire_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "Oocytes  Samples at Different concentrations of ",
  row_title = "Splicing Events of |dPSI|>=0.1",
  column_names_rot = 45,
  column_dend_reorder = c(1:6),
  row_km = number_splices,
  row_dend_reorder = F,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 16),
  show_row_names = FALSE,
  na_col = "transparent"

)
ht = draw(ht); clustered_events<-row_order(ht)
text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(spire_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}

protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")

events_for_impact <- rownames(spire_unique)

final_impact <- data.frame(EventID = rownames(spire_unique)) %>%  # Extract row names as EventID
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))  # Fill missing ONTO values with 0


# Define the left annotation (points) with axis labels
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),  # Adjusted width
    size = unit(4, "mm"),   # Adjusted size of points
    axis_param = list(
      side = "top",
      at = -2:2, # Numeric values to label
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45, # Rotation of labels
      gp = gpar(fontsize = 15) # Text style
    )
  )
)

# Define the right annotation (foo)
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)

```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

ht <- Heatmap(
  spire_unique,
  name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 18, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:6),
  row_km = number_splices,
  left_annotation = left_annotation,   # Add the points on the left
  right_annotation = right_annotation, # Add foo on the right
  row_dend_reorder = F,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"), # Adjust the gap size between rows
  column_gap = unit(4, "mm"), # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend horizontally
  )
)

# Draw the heatmap
ht <- draw(ht)

# Decorate the "foo" annotation slices (on the right)
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}

```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- spire_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

heatmap_dataframe_spire<-heatmap_dataframe
# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```


### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

spire_unique_short <- cbind(
  rowMeans(spire_unique[, 1:3]),
  rowMeans(spire_unique[, 4:6])
)

# Convert to matrix and print result
colnames(spire_unique_short) <- c("Control", "SpireKO")

spire_unique_short <- spire_unique_short[row_order,]

ht <- Heatmap(
  spire_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)

# Draw the heatmap




```

### Enrichment of ORF Disrupted Genes { .tabset}

Note that interpretation should be done taking into account whether that specific ORF-disrupting events is being spliced in or out. This just may give an idea of the ontology of disrupted proteins.

```{r orf enrichr}
enrichdata<-enrichr(reference_table$GENE[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]], databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))



```

#### GO Biological Process

```{r orf bioprocess, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[1]])

datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r orf cellcomponent, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r orf molfunction, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

# Splicing Dynamics Heatmap FMN2

```{r heatmap prep fmndko, results='hide', fig.show='hide'}
set.seed(44)

fmndko_all <- filterEvents(
  fmndko_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR","Alt3","Alt5"),
  N = 3
)

fmndko_unique <- fmndko_all$PSI %>% distinct(EVENT, .keep_all = TRUE) 

fmndko_unique<-fmndko_unique[-which(is.na(fmndko_unique$EVENT)),]
# Set rownames and convert to matrix
rownames(fmndko_unique) <- fmndko_unique$EVENT
fmndko_unique <- as.matrix(fmndko_unique[,7:10])

# Filter rows based on the final event lists and with abs(deltapsi)>=0.1
filtered_events <- unique(c(
  differential_fmndko_exons[abs(differential_fmndko_exons$deltapsi)>=0.1, "EVENT"],
  differential_fmndko_introns[abs(differential_fmndko_introns$deltapsi)>=0.1, "EVENT"]
  ))
fmndko_unique <- fmndko_unique[rownames(fmndko_unique) %in% filtered_events, ]

# Arrange columns based on metadata
# Create a dendrogram for the columns
col_dend <- hclust(dist(t(fmndko_unique))) %>%
  as.dendrogram() %>%
  color_branches(k = 2) # Color branches with 3 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(fmndko_unique))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-6




ht<-Heatmap(
  fmndko_unique, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "Oocytes  Samples at Different concentrations ",
  row_title = "Splicing Events of |dPSI|>=0.1",
  column_names_rot = 45,
  column_dend_reorder = c(1:4),
  row_km = number_splices,
  row_dend_reorder = F,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 16),
  show_row_names = FALSE,
  na_col = "transparent"

)
ht = draw(ht); clustered_events<-row_order(ht)
text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(fmndko_unique)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}

protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t",
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")

events_for_impact<-rownames(fmndko_unique)

final_impact <- data.frame(EventID = rownames(fmndko_unique)) %>%  # Extract row names as EventID
  left_join(protein_impact %>% filter(EventID %in% events_for_impact), by = "EventID") %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))  # Fill missing ONTO values with 0


# Define the left annotation (points) with axis labels
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),  # Adjusted width
    size = unit(4, "mm"),   # Adjusted size of points
    axis_param = list(
      side = "top",
      at = -2:2, # Numeric values to label
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45, # Rotation of labels
      gp = gpar(fontsize = 15) # Text style
    )
  )
)

# Define the right annotation (foo)
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)

```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Biological Process* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The predicted impact on the protein appears on the left.

```{r heatmap_plot fmndko, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

ht <- Heatmap(
  fmndko_unique,
  name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_labels = metadata_fmn2dko$condition,
  column_dend_reorder = c(1:4),
  row_km = number_splices,
  left_annotation = left_annotation,   # Add the points on the left
  right_annotation = right_annotation, # Add foo on the right
  row_dend_reorder = F,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"), # Adjust the gap size between rows
  column_gap = unit(4, "mm"), # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 20),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(20, 30),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend horizontally
  )
)

# Draw the heatmap
ht <- draw(ht)

# Decorate the "foo" annotation slices (on the right)
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 20))
  })
}

```

### Table of Events from Heatmap

**Note**: the *heatmap_cluster* column references to the heatmap row cluster (from top to bottom) that specific event belongs to.

```{r, table heatmap final fmndko}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)


cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- fmndko_unique[row_order, col_order]

final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```

### Same Heatmap but averaging PSI values from same condition

```{r heatmap_plot short fmndko, fig.width=30, fig.height=30, echo=TRUE, out.width="100%"}
set.seed(44)

fmndko_unique_short <- cbind(
  rowMeans(fmndko_unique[, 1:2]),
  rowMeans(fmndko_unique[, 3:4])
)

# Convert to matrix and print result
colnames(fmndko_unique_short) <- c("Control", "FMNDKO")

fmndko_unique_short <- fmndko_unique_short[row_order,]

ht <- Heatmap(
  fmndko_unique_short,
  name = "PSI",
  col = col_fun,
  column_title = "Oocytes Samples",
  column_title_gp = gpar(fontsize = 24, fontface = "bold"),
  row_title = "Splicing Events of |dPSI| >= 0.1",
  row_title_gp = gpar(fontsize = 28, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:3),
  cluster_rows = FALSE,   # <-- This disables row clustering
  cluster_columns = FALSE, # Optionally disable column clustering if desired
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"),      # Adjust the gap size between rows
  left_annotation = left_annotation[row_order],   # Add the points on the left
  right_annotation = right_annotation[row_order],
  column_gap = unit(4, "mm"),   # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 30),
    labels_gp = gpar(fontsize = 30),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend vertically
  )
)

# Draw the heatmap
ht <- draw(ht)

# Draw the heatmap




```

### Enrichment of ORF Disrupted Genes { .tabset}

Note that interpretation should be done taking into account whether that specific ORF-disrupting events is being spliced in or out. This just may give an idea of the ontology of disrupted proteins.

```{r orf enrichr fmndko}
enrichdata<-enrichr(unique(reference_table$GENE[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]]), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))



```

#### GO Biological Process

```{r orf bioprocess fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r orf cellcomponent fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r orf molfunction fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

# System Settings

```{r session info}
sessionInfo()
```
